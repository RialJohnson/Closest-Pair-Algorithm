import java.io.File;
import java.io.FileNotFoundException;
import java.util.*;

public class ClosestPair {
	
	// instance variables
	public static Point[] points;
	public static float[] values;
	private static int globalNumPoints = 0;
	private static int[] indexes;

	public ClosestPair() {
		
		// reads in input from text files
		readIn();

		// initializes a list to store our points, soon to be sorted
		List<Point> points = new ArrayList<Point>();


		// the print statements below are to view what points are being added
		for (int i = 0; i < values.length; i = i + 2) {

			points.add(new Point(values[i], values[i + 1]));

		}
		
		// creates an array to store indexes of points
		indexes = new int[globalNumPoints];
		
		for (int i = 0; i < globalNumPoints; i++) {
			indexes[i] = i;
		}
		
		// starts the recursive divide and conquer process
		Pair finalAnswer = sortLists(points);

		// prints out final solution to the problem
		System.out.println("Final Result: Closest pair: " + finalAnswer.print());

	}

	// reads in points from text file
	public static void readIn() {

		int countValues = 0;

		Scanner scanner;

		try {
			scanner = new Scanner(new File("input.txt"));

			scanner.useLocale(Locale.US);

			String input = "";

			while (scanner.hasNext()) {

				input = input + " " + scanner.next();

			}

			input = input.replaceAll(",", " ");

			Scanner scanner2 = new Scanner(input);

			int j = 0;

			while (scanner2.hasNextFloat()) {

				scanner2.nextFloat();
				countValues++;

			}

			Scanner scanner3 = new Scanner(input);

			values = new float[countValues];

			while (scanner3.hasNextFloat()) {

				values[j] = scanner3.nextFloat();
				j++;

			}

			// sets size for Point array
			points = new Point[countValues / 2];

			// creates points and adds them to an array
			int k = 0;

			for (int i = 0; i < countValues; i = i + 2) {
				points[k] = new Point(values[i], values[i + 1]);
				// the print below states what is being entered in from the text
				// file
				k++;
				globalNumPoints++;
			}

		} catch (FileNotFoundException exception) {

			System.out.print("File not found!");
		}

	}

	public static double getDistance(Point p1, Point p2) {
		// in order to calculate distances we need both the distances of x and y
		// of each coordinate
		double xdist = p2.x - p1.x;
		double ydist = p2.y - p1.y;

		// need hypotenuse to find the full distance
		double hypDistance = Math.hypot(xdist, ydist);

		// rounds to two decimals
		double scale = Math.pow(10, 1);

		double answer = Math.round(hypDistance * scale) / scale;

		return answer;
	}


	// a method to sort x values in the list
	public static void sortX(List<Point> points) {
		
		// built in java functions to sort our points by X
		Collections.sort(points, new Comparator<Point>() {
			public int compare(Point point1, Point point2) {
				if (point1.x < point2.x)
					return -1;
				if (point1.x > point2.x)
					return 1;
				return 0;
			}
		});
	}

	// a method to sort y values in the list
	public static void sortY(List<Point> points) {
		
		// built in java functions to sort our points by X
		Collections.sort(points, new Comparator<Point>() {
			public int compare(Point point1, Point point2) {
				if (point1.y < point2.y)
					return -1;
				if (point1.y > point2.y)
					return 1;
				return 0;
			}
		});
	}

	// puts lists into array lists and then sorts them 	
	public static Pair sortLists(List<Point> points) {
		
		// puts x and y lists into array lists
		List<Point> pointsSortedByX = new ArrayList<Point>(points);
		sortX(pointsSortedByX);
		List<Point> pointsSortedByY = new ArrayList<Point>(points);
		sortY(pointsSortedByY);
		
		// calls the initial algorithm to find closest pair of points
		return algorithm(pointsSortedByX, pointsSortedByY);
	}
	
	// used when we have 3 or fewer pairs 
	public static Pair bruteForce(List<Point> points) {
		
		

		// When we are at the points were we are in the simplest case, we use
		// the bruteforce method to find the the distance

		int numPoints = points.size();
		
		// checks to ensure there are two points to compare
		if (numPoints < 2) {
			
			System.out.println("Found result: INF");
			
			return null;
		}

		// 
		Pair pair = new Pair(points.get(0), points.get(1));
		
		
		System.out.println("Found Result: " + pair.print());
		
		// executes when there are enough points to compare
		if (numPoints > 2) {
			
			
			for (int i = 0; i < numPoints - 1; i++) {
				
				Point point1 = points.get(i);
				for (int j = i + 1; j < numPoints; j++) {
					
					Point point2 = points.get(j);

					double distance = getDistance(point1, point2);
					
					if (distance < pair.distance) {
						pair.update(point1, point2, distance);
						
						System.out.println("Found result: P1: " + point1 + ", P2: " + point2 + ", Distance: " + distance);
						

					}
				}
			}
		}
		
		return pair;
	}

	private static Pair algorithm(List<Point> pointsSortedByX, List<Point> pointsSortedByY) {

		int numPoints = pointsSortedByX.size();
		int rightIndex = numPoints - 1;  
		int leftIndex = 0;
		int endOfList = globalNumPoints - 1;
		int dividingIndex = numPoints / 2 - 1;
		
		// takes care of the case that 2/2 = 1
		if (dividingIndex == 0) {
			dividingIndex = 1;
		}
		
		// the base case is three pairs of points, when the brute force algorithm must be used
		if (numPoints <= 3) {
			System.out.println("Solving Problem: Point[" + leftIndex + "] through Point[" + rightIndex + "]");
			System.out.println("Dividing at Point [" + dividingIndex + "]");
			return bruteForce(pointsSortedByX);
		}
		

		
		System.out.println("Solving Problem: Point[" + leftIndex + "] through Point[" + rightIndex + "]");
		
		System.out.println("Dividing at Point [" + dividingIndex + "]");
		
		
		// STARTS WITH LEFT HALF OF LIST

		// divides current list into left and right sub arrays based off of the
		// parent list's center
		List<Point> leftOfCenter = pointsSortedByX.subList(0, dividingIndex + 1);
		List<Point> rightOfCenter = pointsSortedByX.subList(dividingIndex + 1, rightIndex + 1);


		// creates temporary list to store the sub list into for both the left
		// and right side
		List<Point> tempList = new ArrayList<Point>(leftOfCenter);
		
		sortY(tempList); // sorts those pairs by y value
		
		// the recursive call in the algorithm to divide into smaller problem
		// calls with left values, x and y
		Pair closestPair = algorithm(leftOfCenter, tempList);
		
		
		// NOW TAKES CARE OF RIGHT HALF OF THE LIST

		tempList.clear(); // prevents overlap in temporary list
		
		tempList.addAll(rightOfCenter); //adds second half of pairs
		
		
		sortY(tempList); // sorts those pairs by y value
		
		
		
		Pair closestPairRight = algorithm(rightOfCenter, tempList);
		
		leftIndex = rightIndex + 1;
		
		System.out.println("Solving Problem: Point[" + leftIndex + "] through Point[" + endOfList + "]");
		
		System.out.println("Dividing at Point[" + (endOfList + leftIndex) / 2 + "]");
		
		// finds and sets a new closest pair
		if (closestPairRight.distance < closestPair.distance) {
			closestPair = closestPairRight;
		}

		
		tempList.clear(); // prevents overlap in temporary list

		// create a variable to store the shortest distance of our pairs
		double shortestDistance = closestPair.distance;
		
		// finds the first point in the right sub-list
		double xMid = rightOfCenter.get(0).x;
		
		// begins to combine the lists
		// loops through each point in y
		for (Point point:pointsSortedByY) {
			
			double distanceBetweenHalves = Math.abs(xMid - point.x);
			
			
			
			// checks between sub-problems, and checks if the point is less than the shortest distance
			// in either half
			if (distanceBetweenHalves < shortestDistance) {
				tempList.add(point);
			}
		}
		
		for (int i = 0; i < tempList.size() - 1; i++) {
			
			Point point1 = tempList.get(i); // first point at index i
			
			
			for (int j = i + 1; j < tempList.size(); j++) {
				
				Point point2 = tempList.get(j); // second point to the right of first
				
				if ((point2.y - point1.y) >= shortestDistance) {

					break;
				}
				
				double distance = getDistance(point1, point2);
				
				if (distance < closestPair.distance) {
					closestPair.update(point1, point2, distance);
					shortestDistance = distance;
					
					
					
					
				}
			}
		}
		
		return closestPair;
	}
	
	
}
